"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"datatables-in-ue4ss","metadata":{"permalink":"/blog/datatables-in-ue4ss","source":"@site/blog/2024-02-04-datatables-in-ue4ss.md","title":"DataTables in UE4SS","description":"Devlogging the challenges faced when initially implementing DataTables.","date":"2024-02-04T00:00:00.000Z","tags":[],"readingTime":8.75,"hasTruncateMarker":false,"authors":[{"name":"bitonality"}],"frontMatter":{"title":"DataTables in UE4SS","description":"Devlogging the challenges faced when initially implementing DataTables.","slug":"datatables-in-ue4ss","authors":[{"name":"bitonality"}]},"unlisted":false},"content":"## Background\\r\\n\\r\\n[DataTables](https://docs.unrealengine.com/4.27/en-US/API/Runtime/Engine/Engine/UDataTable/) are a data structure in Unreal Engine that allows for hashed key-value pairs to be loaded at runtime. Common use cases include storing loot tables, experience point requirements for leveling up, base health/armor for actors, etc...\\r\\n\\r\\nDataTables are intended to be populating as part of game compilation and aren\'t *technically* supposed to be modified at runtime. The documentation from Unreal sometimes contradicts this statement, so it\'s a bit hard to parse what\'s *intended* versus what\'s *possible*. My goal is to allow for full read/write/update/delete/iterate operations at runtime from a C++ context without the use of blueprints.\\r\\n\\r\\n## Why not just create a blueprint mod that replaces a DataTable?\\r\\n\\r\\nThis *technically* works. The problem is that your mod is the **only** mod that can change this DataTable. This is obviously not ideal for clients that want to use multiple mods that want to modify the same DataTable. I rate this solution around a 2/10 from a extensibility perspective.\\r\\n\\r\\n## What is the structure of a DataTable?\\r\\n\\r\\nDataTables are build by using `TMap` and `TSet` from native Unreal. If you are familiar with Java\'s `HashMap` or C#\'s `Dictionary` then you\'ll understand the gist of the contracts/usage. Unreal `DataTable` has keys of [`FName`](https://docs.unrealengine.com/4.26/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/StringHandling/FName/) and the value is a struct that inherits from [`FTableRowBase`](https://docs.unrealengine.com/4.27/en-US/API/Runtime/Engine/Engine/FTableRowBase/). More on this later...\\r\\n\\r\\n## So what needs to be done?\\r\\n\\r\\nI will outline a couple of possibilities for the modification of DataTables. I will be evaluating the feasibility/stability of each proposed solution to give some perspective.\\r\\n\\r\\n### Solution 1 (TMap implementation)\\r\\n\\r\\nA DataTable in Unreal Engine exposes a RowMap property that can be accessed:\\r\\n```cpp\\r\\n// DataTable.h\\r\\nvirtual const TMap< FName, uint8 * > & GetRowMap() const \\r\\nvirtual const TMap< FName, uint8 * > & GetRowMap()  \\r\\n```\\r\\nThe GetRowMap() function is reflected and is easily callable by using the UVTD files. The problem is that UE4SS has a bare-bones implementation of TMap. The current TMap implementation in UE4SS can be leveraged in the following manner:\\r\\n```cpp\\r\\n// DataTable row format is <FName, CoolStruct>\\r\\nstruct CoolStruct : FTableRowBase\\r\\n{\\r\\n    FString SomeString;\\r\\n    int_32 SomeNumber;\\r\\n    bool SomeBoolean;\\r\\n}\\r\\n\\r\\nTMap<FName, unsigned char*> rowMap = dataTable->GetRowMap();\\r\\nauto ptrElem = rowMap.GetElementsPtr();\\r\\nfor(int32_t i = 0; i < rowMap.Num(); i++)\\r\\n{\\r\\n    auto pair = &ptrElem[i];\\r\\n    pair->Key;\\r\\n    pair->Value;\\r\\n    CoolStruct* row = reinterpret_cast<CoolStruct*>(pair->Value);\\r\\n}\\r\\n```\\r\\n\\r\\n**So what\'s the big deal?**\\r\\n\\r\\nUE4SS\'s TMap does not like when the underlying data is changed. This way of accessing data works reasonably well for DataTable reads/iterators, but after we call `dt->AddRow()` or `dt->RemoveRow()`, the underlying `.GetElementsPtr()` is inaccurate. If you look at the UE4SS implementation of TMap, you can see that it\'s fairly fragile unless you intend to read only.\\r\\n\\r\\nNote that the current `.Num()` function in UE4SS TMap does not actually perform calculations on the TMap. The `Num` property is just set when we construct a TMap in UE4SS, so we don\'t get updates when the underlying size changes.\\r\\n\\r\\nI suppose this solution is reasonable for reading a DataTable if that\'s all you want to do.\\r\\n\\r\\nSo how can we make this work?\\r\\n\\r\\nTheoretically we can implement TMap in UE4SS with mirrored functionality to UE native. UE4SS has done a similar approach with `TArray`. The potential downsides are that if TMap underlying logic/structures have changed between UE versions, then we would need multiple implementations that represent the state of UE TMaps at different versions. Either that, or, we could have `#if UE5_1` etc. to keep things consolidated in a single TMap.hpp/cpp file.\\r\\n\\r\\nWill implementing TMap in UE4SS work for modifying DataTables? I haven\'t completed a thorough investigation, but my gut says... *probably?*\\r\\n\\r\\n**Why can\'t we use FindRow/GetRow on the DataTable object?**\\r\\n\\r\\nThe only useful reflected functions we get from `UDataTable` dump is `GetRowMap()`, `RemoveRow()`, and `AddRow()`. Not too shabby, but unfortunate that we can\'t get a row directly or use a UE4SS `TMap` to get a row.\\r\\n\\r\\n\\r\\n### Solution 2 (Kismet DataTable Helper Library)\\r\\nThis approach leverages a blueprint [DataTable helper class](https://docs.unrealengine.com/4.27/en-US/API/Runtime/Engine/Kismet/UDataTableFunctionLibrary/) built into Unreal Engine. The reflected functions from this blueprint helper are:\\r\\n```cpp\\r\\nstatic bool DoesDataTableRowExist\\r\\n(\\r\\n    UDataTable * Table,\\r\\n    FName RowName\\r\\n) \\r\\n\\r\\nstatic void GetDataTableRowNames\\r\\n(\\r\\n    UDataTable * Table,\\r\\n    TArray< FName > & OutRowNames\\r\\n) \\r\\n\\r\\nstatic bool GetDataTableRowFromName\\r\\n(\\r\\n    UDataTable * Table,\\r\\n    FName RowName,\\r\\n    FTableRowBase & OutRow\\r\\n) \\r\\n```\\r\\n\\r\\nIf you\'ve been paying attention, then a light bulb might be going off in your head. Seems like we could accomplish full DataTable support by utilizing\\r\\n```cpp\\r\\n// DataTable reflected functions\\r\\nAddRow();\\r\\nRemoveRow();\\r\\nEmpty();\\r\\n\\r\\n// DataTableFunctionLibrary reflected functions\\r\\nDoesDataTableRowExist();\\r\\nGetDataTableRowNames();\\r\\nGetDataTableRowFromName();\\r\\n```\\r\\n\\r\\n**But there\'s always a catch...**\\r\\n\\r\\n`GetDataTableRowFromName();` is an especially cursed function. The TLDR is that it\'s *probably* usable, but will require some further experimentation.\\r\\n\\r\\nThis next section benefits from somewhat of an intimate knowledge of how Kismet/blueprints/FFrame and the blueprint scripting stack works. I\'ll include some pre-reads to familiarize yourself.\\r\\n\\r\\n* [Custom Thunks TLDR](https://gist.github.com/intaxwashere/e9b1f798427686b46beab2521d7efbcf)\\r\\n* [Blueprints from C++](https://intaxwashere.github.io/blueprint-access/)\\r\\n* [Blueprint Function Templates](https://neil3d.github.io/unreal/blueprint-wildcard.html)\\r\\n\\r\\n`GetDataTableRowFromName()` has the [specifiers](https://docs.unrealengine.com/4.26/en-US/ProgrammingAndScripting/GameplayArchitecture/Functions/Specifiers/) `CustomThunk` and `CustomStructureParam`.\\r\\n\\r\\n```\\r\\nCustomThunk:\\r\\nThe UnrealHeaderTool code generator will not produce a thunk for this function; it is up to the user to provide one with the DECLARE_FUNCTION or DEFINE_FUNCTION macros.\\r\\n\\r\\nCustomStructureParam:\\r\\nThe listed parameters are all treated as wildcards. This specifier requires the UFUNCTION-level specifier, CustomThunk, which will require the user to provide a custom exec function. In this function, the parameter types can be checked and the appropriate function calls can be made based on those parameter types. The base UFUNCTION should never be called, and should assert or log an error if it is. \\r\\n```\\r\\n\\r\\nUnder the hood, the `GetDataTableRowFromName()` UFunction is just a stub. The DataTableFunctionLibrary provides the actual behavior with a `DEFINE_FUNCTION(execGetDataTableRowFromName)` macro. Let\'s take a look at what the defined function is:\\r\\n```cpp\\r\\n// DataTableFunctionLibrary.h\\r\\n /** Based on UDataTableFunctionLibrary::GetDataTableRow */\\r\\n DECLARE_FUNCTION(execGetDataTableRowFromName)\\r\\n {\\r\\n     P_GET_OBJECT(UDataTable, Table);\\r\\n     P_GET_PROPERTY(FNameProperty, RowName);\\r\\n     \\r\\n     Stack.StepCompiledIn<FStructProperty>(NULL);\\r\\n     void* OutRowPtr = Stack.MostRecentPropertyAddress;\\r\\n\\r\\n\\t\\tP_FINISH;\\r\\n\\t\\tbool bSuccess = false;\\r\\n\\t\\t// The following line fails to find the StructProp. See notes below this code block for the specifics.\\r\\n\\t\\tFStructProperty* StructProp = CastField<FStructProperty>(Stack.MostRecentProperty);\\r\\n\\t\\tif (!Table)\\r\\n\\t\\t{\\r\\nFBlueprintExceptionInfo ExceptionInfo(\\r\\n\\tEBlueprintExceptionType::AccessViolation,\\r\\n\\tNSLOCTEXT(\\"GetDataTableRow\\", \\"MissingTableInput\\", \\"Failed to resolve the table input. Be sure the DataTable is valid.\\")\\r\\n);\\r\\nFBlueprintCoreDelegates::ThrowScriptException(P_THIS, Stack, ExceptionInfo);\\r\\n\\t\\t}\\r\\n\\t\\telse if(StructProp && OutRowPtr)\\r\\n\\t\\t{\\r\\nUScriptStruct* OutputType = StructProp->Struct;\\r\\nconst UScriptStruct* TableType  = Table->GetRowStruct();\\r\\n\\t\\t\\r\\nconst bool bCompatible = (OutputType == TableType) || \\r\\n\\t(OutputType->IsChildOf(TableType) && FStructUtils::TheSameLayout(OutputType, TableType));\\r\\nif (bCompatible)\\r\\n{\\r\\n\\tP_NATIVE_BEGIN;\\r\\n\\tbSuccess = Generic_GetDataTableRowFromName(Table, RowName, OutRowPtr);\\r\\n\\tP_NATIVE_END;\\r\\n}\\r\\nelse\\r\\n{\\r\\n\\tFBlueprintExceptionInfo ExceptionInfo(\\r\\n\\t\\tEBlueprintExceptionType::AccessViolation,\\r\\n\\t\\tNSLOCTEXT(\\"GetDataTableRow\\", \\"IncompatibleProperty\\", \\"Incompatible output parameter; the data table\'s type is not the same as the return type.\\")\\r\\n\\t\\t);\\r\\n\\tFBlueprintCoreDelegates::ThrowScriptException(P_THIS, Stack, ExceptionInfo);\\r\\n}\\r\\n\\t\\t}\\r\\n\\t\\telse\\r\\n\\t\\t{\\r\\nFBlueprintExceptionInfo ExceptionInfo(\\r\\n\\tEBlueprintExceptionType::AccessViolation,\\r\\n\\tNSLOCTEXT(\\"GetDataTableRow\\", \\"MissingOutputProperty\\", \\"Failed to resolve the output parameter for GetDataTableRow.\\")\\r\\n);\\r\\nFBlueprintCoreDelegates::ThrowScriptException(P_THIS, Stack, ExceptionInfo);\\r\\n\\t\\t}\\r\\n\\t\\t*(bool*)RESULT_PARAM = bSuccess;\\r\\n }\\r\\n```\\r\\n\\r\\nThe issue is that the Stack.MostRecentProperty does not get populated when we call the `GetDataTableRowFromName()` from a C++ context. This specifics of this have been documented at by the following GitHub issues:\\r\\n\\r\\n* [Issue 1](https://github.com/Tencent/puerts/issues/836) (CN)\\r\\n* [Issue 2](https://github.com/Tencent/puerts/issues/986) (CN)\\r\\n\\r\\nUnder the hood:\\r\\n```cpp\\r\\nstatic bool GetDataTableRowFromName\\r\\n(\\r\\n    UDataTable * Table,\\r\\n    FName RowName,\\r\\n    FTableRowBase & OutRow\\r\\n)\\r\\n\\r\\n// Does some property reading, type checking, etc,\\r\\n// Then internally it calls\\r\\n\\r\\nstatic bool Generic_GetDataTableRowFromName\\r\\n(\\r\\n    const UDataTable * Table,\\r\\n    FName RowName,\\r\\n    void * OutRowPtr\\r\\n) \\r\\n```\\r\\n\\r\\nIt would be suitable for us to use a `void*` for the `OutRow` instead of a ref `FTableRowBase`, but as fate would have it, this `Generic_GetDataTableRowFromName()` is not accessible via reflection.\\r\\n\\r\\nThe core of the problem is that the `execGetDataTableRowFromName()` is particularly aggressive at typechecking and ensuring that the function will work or gracefully exit. This is expected since this function is a blueprint node and needs to be a robust function to work within the blueprint framework. The specific way that `Stack.MostRecentProperty` is used is to determine the target type of Struct that we expect to retrieve from the DataTable. In the blueprint caller context, this property would be populated as part of the Kismet FFrame/Stack pipeline.\\r\\n\\r\\n**Anything we can do?**\\r\\n\\r\\nI am currently playing with manually setting the `Stack.MostRecentProperty` to trick the `GetDataTableRowFromName()` into *thinking* that we\'re calling the function as part of a legal blueprint function and not directly from C++ code. Like solution 1, I rate this solution as a *probably?* in the functionality department.\\r\\n\\r\\n### One final wrench in the machine...\\r\\nThere\'s also further research needed about how DataTable row structs are stored in memory. It appears some games might have compiler packing, but the extent of this is still unknown. Furthermore, some games have reasonably laid out struct members for memory footprint/alignment/padding purposes, and other games have their struct members in a way that makes sense from a readability standpoint, but not from a memory optimization standpoint. \\r\\n\\r\\n```cpp\\r\\n// NameTypes.hpp (UE4SS)\\r\\n\\r\\n// TODO:   Figure out what\'s going on here\\r\\n//         It shouldn\'t be required to use \'alignas\' here to make sure it\'s aligned properly in containers (like TArray)\\r\\n//         I\'ve never seen an FName not be 8-byte aligned in memory,\\r\\n//         but it is 4-byte aligned in the source so hopefully this doesn\'t cause any problems\\r\\n// UPDATE: This matters in the UE VM, when ElementSize is 0xC in memory for case-preserving games, it must be aligned by 0x4 in that case\\r\\n#pragma warning(disable: 4324) // Suppressing warning about struct alignment\\r\\n#ifdef WITH_CASE_PRESERVING_NAME\\r\\n    struct alignas(4) RC_UE_API FName\\r\\n#else\\r\\n    struct alignas(8) RC_UE_API FName // FNames in DataTable rows seem to only work with alignas(4)\\r\\n```\\r\\n\\r\\nThe above code is a TODO: that\'s still in UE4SS. The investigation of alignment will likely have benefits across other non-DataTable parts! We\'ll need to understand the full extent of alignment/padding regardless of which solution we use (TMap or Blueprint Library or Other).\\r\\n\\r\\n## Disclaimer\\r\\nWhile I feel that I have a good understanding of the factors at play, I have no doubt that I\'ve missed some of the nuance and have misunderstood parts of the underlying systems. Please let me know if you think something operates differently than is currently documented. I would really appreciate the help!\\r\\n\\r\\n## Got any ideas?\\r\\nPlease reach out in the UE4SS Discord to brainstorm/share any ideas you might have. While I am currently in the role as feature lead for DataTables, I appreciate all the help I can get.\\r\\n\\r\\n## Other Resources\\r\\n\\r\\n* [DataTable Pull Request](https://github.com/Re-UE4SS/UEPseudo/pull/74/commits/04ef456ea337c59bc2df8ba9162ce4a7e52de445) - I think you need Epic Games group access to view this?\\r\\n* [UE5 Wiki](https://ue5wiki.com/wiki/34184/) (CN)\\r\\n* [UE4SS Docs](https://docs.ue4ss.com/)\\r\\n* [JIP Blog](https://jip.dev/notes/unreal-engine/)\\r\\n\\r\\n## Credits\\r\\nSpecial thanks to localcc for being a wonderful mentor. Shout out to all early adopters of the DataTable branches (special thanks to El for being our first early adopter).\\r\\n\\r\\n\\r\\nThanks for your continued patience. \\r\\n\\r\\n-- bitonality"}]}}')}}]);